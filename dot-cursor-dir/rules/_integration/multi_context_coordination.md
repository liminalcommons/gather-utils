---
description: USE WHEN: coordinating changes across multiple system contexts (code, release, agent)
globs: 
alwaysApply: false
---
---
description: "Guidance for coordinating changes across multiple system contexts"
globs: "**/cross-context/**/*.md,**/integration/**/*.md,**/coordination/**/*.md"
priority: 2
alwaysApply: false
type: "Agent-Requested"
---

# Multi-Context Coordination Framework

<critical>
When changes span multiple system contexts (code, release process, agent), apply this framework to ensure coordinated implementation, proper integration, and consistent principle application across boundaries.
</critical>

## Coordination Fundamentals

### Context Boundary Types

Understanding the types of boundaries between system contexts:

```markdown
## Context Boundary Types

### Code-to-Release Process Boundary
- Release process guidance impacts code implementation
- Code structure affects release process efficiency
- Tool integrations connect code and process
- Documentation links processes to code

### Release Process-to-Agent Boundary
- Agent guidelines reference release processes
- Process documentation informs agent knowledge
- Agent capabilities support process activities
- Process metrics guide agent improvement

### Agent-to-Code Boundary
- Agent creates and modifies code
- Code patterns inform agent behavior
- Agent knowledge reflects code structure
- Code documentation guides agent understanding

### Tri-Context Integration Points
- Meta-systemic principles applied across all contexts
- Documentation spans all three contexts
- Knowledge management crosses all boundaries
- Validation spans all contexts
```

### Cross-Context Change Patterns

Common patterns for changes that span contexts:

```yaml
cross_context_patterns:
  - name: "Coordinated Evolution"
    description: "Planned changes that impact multiple contexts simultaneously"
    examples:
      - "New feature requiring code, process updates, and agent guidance"
      - "Architectural change affecting all contexts"
      - "Principle emphasis adjustment across contexts"
  
  - name: "Sequential Adaptation"
    description: "Changes that cascade from one context to others"
    examples:
      - "Code changes necessitating process adjustments and agent updates"
      - "Process changes requiring code updates and agent adaptation"
      - "Agent capability changes affecting process guidance and code patterns"
  
  - name: "Boundary Reinforcement"
    description: "Changes that strengthen context boundaries"
    examples:
      - "Interface clarification between contexts"
      - "Boundary documentation improvement"
      - "Cross-context validation enhancement"
  
  - name: "Context Alignment"
    description: "Changes that establish consistency across contexts"
    examples:
      - "Terminology standardization across contexts"
      - "Pattern harmonization across boundaries"
      - "Consistent principle application across contexts"
```

## Coordination Process Framework

When implementing changes that span multiple contexts:

### 1. Change Impact Analysis

Assess the impact across contexts:

```markdown
## Cross-Context Impact Analysis

### Primary Context
- **Context**: [Code/Release Process/Agent]
- **Change Scope**: [Description of changes in primary context]
- **Components Affected**: [List of affected components]
- **Principle Focus**: [Key principles being applied]

### Secondary Context Impacts
- **Context**: [Code/Release Process/Agent]
- **Impact Type**: [Direct/Indirect/Induced]
- **Components Affected**: [List of affected components]
- **Required Changes**: [Description of necessary changes]
- **Principle Considerations**: [Principle application considerations]

### Tertiary Context Impacts
- **Context**: [Code/Release Process/Agent]
- **Impact Type**: [Direct/Indirect/Induced]
- **Components Affected**: [List of affected components]
- **Required Changes**: [Description of necessary changes]
- **Principle Considerations**: [Principle application considerations]

### Cross-Boundary Considerations
- **Key Interfaces**: [Interfaces between contexts]
- **Integration Points**: [Points where contexts interact]
- **Knowledge Transfer Requirements**: [Information that must be shared]
- **Principle Tension Areas**: [Areas where principles may conflict]
```

### 2. Coordination Planning

Create an integrated plan for cross-context changes:

```markdown
## Cross-Context Coordination Plan

### Change Sequence
- **Phase 1**: [Initial changes with context and scope]
  - Dependencies: [Pre-requisites]
  - Validation: [Validation approach]
  - Stakeholders: [Involved parties]

- **Phase 2**: [Subsequent changes with context and scope]
  - Dependencies: [Pre-requisites, including Phase 1 items]
  - Validation: [Validation approach]
  - Stakeholders: [Involved parties]

- **Phase 3**: [Final changes with context and scope]
  - Dependencies: [Pre-requisites, including Phase 2 items]
  - Validation: [Validation approach]
  - Stakeholders: [Involved parties]

### Integration Points
- **Point 1**: [Description of integration point]
  - Contexts: [Contexts being integrated]
  - Integration Mechanism: [How integration occurs]
  - Validation: [How to verify successful integration]

- **Point 2**: [Description of integration point]
  - Contexts: [Contexts being integrated]
  - Integration Mechanism: [How integration occurs]
  - Validation: [How to verify successful integration]

### Cross-Context Synchronization
- **Milestone 1**: [Description with expected date]
  - Synchronization Event: [What triggers synchronization]
  - Required State: [What must be true across contexts]
  - Validation: [How to verify synchronization]

- **Milestone 2**: [Description with expected date]
  - Synchronization Event: [What triggers synchronization]
  - Required State: [What must be true across contexts]
  - Validation: [How to verify synchronization]
```

### 3. Cross-Context Implementation

Execute changes with appropriate coordination:

```markdown
## Cross-Context Implementation Approach

### Implementation Principles
- Maintain visibility across contexts
- Validate integration points incrementally
- Ensure knowledge transfer between contexts
- Apply meta-systemic principles consistently
- Coordinate timing of interdependent changes

### Context-Specific Implementation Guidance

#### Code Context Implementation
- **Approach**: [Implementation approach in code context]
- **Key Considerations**: [Important factors for code changes]
- **Boundaries to Maintain**: [Code boundaries to preserve]
- **Integration Points**: [Where code connects to other contexts]

#### Release Process Context Implementation
- **Approach**: [Implementation approach in process context]
- **Key Considerations**: [Important factors for process changes]
- **Boundaries to Maintain**: [Process boundaries to preserve]
- **Integration Points**: [Where process connects to other contexts]

#### Agent Context Implementation
- **Approach**: [Implementation approach in agent context]
- **Key Considerations**: [Important factors for agent changes]
- **Boundaries to Maintain**: [Agent boundaries to preserve]
- **Integration Points**: [Where agent connects to other contexts]

### Cross-Context Reviews
- **Review 1**: [Description and timing]
  - Focus: [What to validate]
  - Participants: [Who should be involved]
  - Criteria: [Success criteria]

- **Review 2**: [Description and timing]
  - Focus: [What to validate]
  - Participants: [Who should be involved]
  - Criteria: [Success criteria]
```

### 4. Cross-Context Validation

Validate changes across context boundaries:

```markdown
## Cross-Context Validation Framework

### Boundary Validation
- **Code-to-Process Boundary**:
  - Validation Approach: [How to validate]
  - Success Criteria: [What must be true]
  - Evidence Required: [What evidence to collect]

- **Process-to-Agent Boundary**:
  - Validation Approach: [How to validate]
  - Success Criteria: [What must be true]
  - Evidence Required: [What evidence to collect]

- **Agent-to-Code Boundary**:
  - Validation Approach: [How to validate]
  - Success Criteria: [What must be true]
  - Evidence Required: [What evidence to collect]

### End-to-End Validation
- **Scenario 1**: [Description of cross-context scenario]
  - Steps: [Step-by-step validation process]
  - Expected Results: [What should happen]
  - Validation Method: [How to verify]

- **Scenario 2**: [Description of cross-context scenario]
  - Steps: [Step-by-step validation process]
  - Expected Results: [What should happen]
  - Validation Method: [How to verify]

### Meta-Systemic Principle Validation
- **Principle 1**: [Principle name]
  - Cross-Context Application: [How principle applies across contexts]
  - Validation Approach: [How to validate]
  - Success Criteria: [What must be true]

- **Principle 2**: [Principle name]
  - Cross-Context Application: [How principle applies across contexts]
  - Validation Approach: [How to validate]
  - Success Criteria: [What must be true]
```

### 5. Integration Documentation

Document the integration between contexts:

```markdown
## Cross-Context Integration Documentation

### Integration Overview
- **Purpose**: [Why the integration is needed]
- **Contexts Involved**: [List of contexts]
- **Key Integration Points**: [Summary of integration points]
- **Principles Applied**: [Key principles for integration]

### Context Boundaries
- **Boundary 1**: [Description of context boundary]
  - Interface Definition: [How contexts interact]
  - Responsibility Division: [What each context handles]
  - Information Exchange: [What information crosses the boundary]

- **Boundary 2**: [Description of context boundary]
  - Interface Definition: [How contexts interact]
  - Responsibility Division: [What each context handles]
  - Information Exchange: [What information crosses the boundary]

### Cross-Context Dependencies
- **Dependency 1**: [Description of dependency]
  - Source Context: [Where dependency originates]
  - Target Context: [Where dependency impacts]
  - Nature of Dependency: [How the dependency functions]
  - Management Approach: [How to manage the dependency]

- **Dependency 2**: [Description of dependency]
  - Source Context: [Where dependency originates]
  - Target Context: [Where dependency impacts]
  - Nature of Dependency: [How the dependency functions]
  - Management Approach: [How to manage the dependency]

### Evolution Considerations
- **Future Changes**: [Anticipated future changes]
- **Versioning Approach**: [How to version cross-context interfaces]
- **Migration Strategy**: [How to handle future migrations]
- **Backward Compatibility**: [Backward compatibility requirements]
```

## Meta-Systemic Principle Application

### Parsimony Across Contexts
- Define concepts once and reference across contexts
- Maintain canonical definitions that span contexts
- Create cross-references rather than duplicating
- Establish clear knowledge relationships across boundaries

Example:
```markdown
## Cross-Context Definition: Release Validation

This concept is defined once and referenced across contexts:

### Canonical Definition
Release validation is the process of verifying that a release meets quality criteria and requirements before deployment.

### Context-Specific References

**Code Context:** 
Code validation applies the canonical release validation definition through automated tests, code reviews, and quality metrics. Reference the [Validation Framework](mdc:../validation/framework.md) rather than redefining validation requirements.

**Process Context:**
Process documentation references the canonical release validation definition and extends it with process-specific validation activities. See the [Validation Phase](mdc:../lifecycle/validation-phase.md) for process-specific guidance.

**Agent Context:**
Agent guidance references the canonical release validation definition and applies it to agent-specific validation activities. See the [Agent Validation](mdc:../agent/validation-guidance.md) for agent-specific adaptation.
```

### Tensegrity Across Contexts
- Create balanced relationships between contexts
- Ensure mutual support across boundaries
- Design resilient connections between contexts
- Implement appropriate dependency management

Example:
```markdown
## Cross-Context Tensegrity: Validation Process

The validation process demonstrates tensegrity across contexts:

### Mutual Support Structure

**Code Context Provides:**
- Automated tests that verify requirements
- Quality metrics for objective assessment
- Technical validation capabilities
- Self-validation through test coverage

**Process Context Provides:**
- Validation framework and methodology
- Quality criteria definitions
- Structured validation process
- Documentation for validation approach

**Agent Context Provides:**
- Principle validation expertise
- Pattern consistency checking
- Validation documentation generation
- Knowledge application validation

### Balanced Dependencies

Each context both supports and is supported by the others:
- Code depends on process for validation criteria, while process depends on code for validation execution
- Process depends on agent for principle validation, while agent depends on process for validation framework
- Agent depends on code for validation targets, while code depends on agent for pattern consistency
```

### Modularity Across Contexts
- Define clear boundaries between contexts
- Create explicit interfaces for cross-context interaction
- Encapsulate context-specific implementation details
- Design for independent evolution of contexts

Example:
```markdown
## Cross-Context Modularity: Reporting Interface

The reporting interface demonstrates modularity across contexts:

### Context Boundaries

**Code Context Boundary:**
- Generates raw metrics and data
- Exposes data through defined API
- Encapsulates data collection details
- Maintains data model integrity

**Process Context Boundary:**
- Defines report structure and requirements
- Provides templates and formats
- Encapsulates process interpretation
- Maintains process documentation

**Agent Context Boundary:**
- Generates analysis and insights
- Provides pattern detection
- Encapsulates knowledge application
- Maintains interpretation guidelines

### Interface Contracts

**Code-to-Process Interface:**
- API contract: `generateMetrics(scope, criteria) -> MetricsData`
- Data format: JSON with specified schema
- Error handling: Defined error codes and recovery
- Performance requirements: Response within 5 seconds

**Process-to-Agent Interface:**
- Template contract: `standardReportFormat(type) -> ReportTemplate`
- Interpretation guidelines: Documented in process files
- Visualization standards: Defined chart formats
- Reporting periods: Standard intervals defined

**Agent-to-Code Interface:**
- Analysis contract: `analyzeMetricTrends(data) -> TrendAnalysis`
- Pattern matching: Defined pattern recognition criteria
- Recommendation guidelines: Structured format
- Knowledge application: Documented principle application
```

### Coherence Across Contexts
- Apply consistent patterns across contexts
- Maintain terminology alignment between contexts
- Ensure predictable interactions across boundaries
- Create unified experience across the system

Example:
```markdown
## Cross-Context Coherence: Error Handling

Error handling demonstrates coherence across contexts:

### Consistent Error Patterns

**Common Structure:**
- Error identification: Unique error codes with context prefix
- Error classification: Consistent severity levels
- Error documentation: Standard format with cause, impact, resolution
- Error reporting: Uniform logging and notification

**Code Context Implementation:**
- Error codes: `CODE-[category]-[id]`
- Exception hierarchy: Standardized exception classes
- Logging pattern: Structured JSON with context
- Recovery approach: Defined retry and fallback strategies

**Process Context Implementation:**
- Error codes: `PROC-[category]-[id]`
- Process exceptions: Documented process exception paths
- Documentation pattern: Standard section in process docs
- Recovery approach: Defined process alternatives

**Agent Context Implementation:**
- Error codes: `AGNT-[category]-[id]`
- Knowledge limits: Clear boundary definitions
- Guidance pattern: Standard responses for error types
- Recovery approach: Defined escalation paths
```

### Clarity Across Contexts
- Provide explicit cross-context documentation
- Include examples of cross-context interactions
- Document interfaces and integration points clearly
- Explain rationale for cross-context decisions

Example:
```markdown
## Cross-Context Clarity: Release Planning

Release planning demonstrates clarity across contexts:

### Cross-Context Documentation

**Explicit Interface Documentation:**
```
## Release Planning Integration Points

### Code-to-Process Integration
The release planning process consumes the technical feasibility assessment from the code context:

Example:
```json
{
  "feature": "Enhanced Search",
  "assessment": {
    "complexity": "Medium",
    "dependencies": ["Indexing Service", "Query Parser"],
    "estimatedEffort": "15 person-days",
    "technicalRisks": [
      {
        "risk": "Performance degradation",
        "likelihood": "Medium",
        "mitigation": "Performance testing during development"
      }
    ]
  }
}
```

### Process-to-Agent Integration
The release planning process provides structure while the agent provides analysis:

Example:
```
Agent analysis of technical feasibility:
Based on the technical feasibility assessment, I recommend these adjustments:
1. Increase the estimated effort to 20 person-days due to the complexity of the query parser integration
2. Add a risk for index compatibility with existing data
3. Consider splitting the feature into two phases for better risk management
```

### Rationale for Integration Approach
This integration structure was chosen because:
1. It maintains clear responsibility separation while enabling collaboration
2. It leverages the strengths of each context (technical expertise, process structure, pattern analysis)
3. It provides clear documentation of cross-context decisions
4. It ensures traceability from planning to implementation
```

### Adaptivity Across Contexts
- Design for appropriate variation across contexts
- Adapt integration approaches to specific needs
- Allow context-specific implementations while maintaining coherence
- Document context adaptations with rationale

Example:
```markdown
## Cross-Context Adaptivity: Validation Approach

Validation demonstrates adaptivity across contexts:

### Context-Specific Adaptations

**Shared Core Elements:**
- Validation principles: Completeness, correctness, consistency
- Core validation process: Plan, execute, report
- Essential artifacts: Validation plan, validation report
- Success criteria framework: Pass/fail/conditional

**Code Context Adaptation:**
- **Adaptation:** Automated test-driven validation
- **Rationale:** Enables efficient regression testing and CI/CD
- **Implementation:** Test suites with automated execution
- **Boundary Maintenance:** Standard reporting format

**Process Context Adaptation:**
- **Adaptation:** Checklist-based structured validation
- **Rationale:** Ensures comprehensive coverage of process elements
- **Implementation:** Phase-specific validation checklists
- **Boundary Maintenance:** Standard validation criteria

**Agent Context Adaptation:**
- **Adaptation:** Example-based capability validation
- **Rationale:** Best approach for verifying intelligent behavior
- **Implementation:** Scenario-based testing with expected responses
- **Boundary Maintenance:** Standard capability definitions
```

## Common Cross-Context Patterns

### Coordinated Release Pattern

When implementing features that span contexts:

```markdown
## Coordinated Release Pattern

### Pattern Structure
1. **Unified Definition**: Create a cross-context release definition
2. **Coordinated Planning**: Develop integrated plan across contexts
3. **Synchronized Development**: Implement with cross-context coordination
4. **Integrated Validation**: Validate across all context boundaries
5. **Coordinated Deployment**: Deploy changes together with verification
6. **Unified Evaluation**: Assess effectiveness across all contexts

### Context Responsibilities

**Code Context Responsibilities:**
- Implement technical features
- Create automated tests
- Ensure technical quality
- Maintain system integrity

**Process Context Responsibilities:**
- Define release process
- Create documentation
- Establish validation criteria
- Coordinate activities

**Agent Context Responsibilities:**
- Develop required capabilities
- Create guidance materials
- Ensure principle application
- Support implementation

### Synchronization Points
- **Definition Approval**: All contexts sign off on unified definition
- **Planning Complete**: Integrated plan approved across contexts
- **Feature Complete**: All context implementations complete
- **Validation Complete**: Cross-context validation passed
- **Deployment Go/No-Go**: Final deployment decision

### Integration Validation
For each integration point, validate:
1. Correct information exchange
2. Appropriate boundary maintenance
3. Consistent principle application
4. Mutual support across contexts
```

### Incremental Alignment Pattern

When gradually bringing contexts into alignment:

```markdown
## Incremental Alignment Pattern

### Pattern Structure
1. **Current State Assessment**: Document current alignment across contexts
2. **Target State Definition**: Define desired cross-context alignment
3. **Gap Analysis**: Identify misalignments between contexts
4. **Prioritization**: Rank alignment needs by impact and effort
5. **Incremental Implementation**: Align contexts one area at a time
6. **Continuous Validation**: Verify alignment with each change

### Alignment Areas

**Terminology Alignment:**
- Create cross-context glossary
- Standardize terms across contexts
- Update documentation for consistency
- Validate term usage in each context

**Pattern Alignment:**
- Identify core patterns used across contexts
- Create canonical pattern definitions
- Update context-specific implementations
- Validate pattern consistency

**Principle Application Alignment:**
- Assess principle application in each context
- Identify inconsistencies in application
- Create unified principle guidelines
- Validate consistent application

### Implementation Approach
- Start with high-impact, low-effort alignments
- Implement changes in coordinated increments
- Update all affected artifacts in each increment
- Validate cross-context consistency after each increment

### Success Measures
- Reduced confusion and misunderstanding
- Improved cross-context collaboration
- More efficient integration
- Consistent experience across contexts
```

### Interface Evolution Pattern

When evolving interfaces between contexts:

```markdown
## Interface Evolution Pattern

### Pattern Structure
1. **Current Interface Assessment**: Document current interfaces
2. **Evolution Requirements**: Define needed interface changes
3. **Compatibility Analysis**: Assess impact across contexts
4. **Transition Design**: Create transition approach for each interface
5. **Coordinated Implementation**: Update interfaces with appropriate sequencing
6. **Backward Compatibility**: Maintain support during transition

### Interface Types

**Data Interfaces:**
- Schema definitions
- Serialization formats
- Exchange protocols
- Validation rules

**Process Interfaces:**
- Handoff procedures
- Approval workflows
- Status communication
- Coordination protocols

**Knowledge Interfaces:**
- Reference formats
- Information exchange
- Guidance application
- Learning feedback

### Evolution Approaches

**Versioned Evolution:**
- Create new interface version
- Support both versions during transition
- Migrate consumers to new version
- Deprecate old version after migration

**Compatible Extension:**
- Add new capabilities to existing interface
- Maintain backward compatibility
- Document extensions clearly
- Validate with existing consumers

**Breaking Change with Migration:**
- Create new interface that breaks compatibility
- Develop migration tools and guidance
- Coordinate transition across contexts
- Remove old interface after transition

### Validation Requirements
- Test interfaces from both provider and consumer sides
- Verify backward compatibility where required
- Validate error handling and edge cases
- Ensure documentation is updated
```

## Human-AI Collaboration for Cross-Context Coordination

In our two-person team:

### Human Team Member Focus
- Making strategic decisions about cross-context integration
- Resolving ambiguities and conflicts between contexts
- Providing domain expertise for context-specific details
- Evaluating cross-context tradeoffs
- Approving integration approaches

### AI Agent Focus
- Ensuring consistency across context boundaries
- Documenting cross-context integration clearly
- Identifying potential conflicts or misalignments
- Maintaining traceability across contexts
- Supporting implementation with cross-context awareness

## Cross-Context Coordination Examples

### Example 1: New Feature Implementation

```markdown
## Cross-Context Coordination: Enhanced Search Feature

### Feature Overview
The Enhanced Search feature requires changes across all three contexts:
- **Code Context**: New search engine implementation with semantic capabilities
- **Process Context**: Updated validation process for search relevance
- **Agent Context**: New capability for semantic pattern analysis

### Coordination Approach

**Phase 1: Definition and Planning**
- Create unified feature definition across contexts
- Develop integrated implementation plan
- Define cross-context interfaces
- Establish coordination checkpoints

**Phase 2: Core Implementation**
- Implement search engine in code context
- Create validation framework in process context
- Develop pattern analysis in agent context
- Validate interfaces between contexts

**Phase 3: Integration**
- Connect search engine to pattern analysis
- Integrate validation process with both contexts
- Perform cross-context validation
- Refine based on validation results

**Phase 4: Deployment**
- Coordinate deployment across contexts
- Verify integration in production
- Monitor cross-context interactions
- Document final implementation

### Interface Definitions

**Code-to-Agent Interface:**
```json
{
  "searchRequest": {
    "query": "Example search query",
    "options": {
      "semantic": true,
      "filters": { "type": "document" }
    }
  },
  "searchResponse": {
    "results": [...],
    "metadata": {
      "semanticAnalysis": {...},
      "relevanceScores": [...]
    }
  }
}
```

**Process-to-Code Interface:**
```
Validation Criteria:
1. Relevance score > 0.7 for exact match queries
2. Response time < 200ms for 95th percentile
3. Semantic matching identifies synonyms correctly
```

**Agent-to-Process Interface:**
```
Pattern Analysis Report:
- Semantic pattern consistency: 92%
- Query interpretation accuracy: 88%
- Relevance improvement: +35% over baseline
```
```

### Example 2: Architectural Change

```markdown
## Cross-Context Coordination: Microservice Migration

### Change Overview
The microservice migration affects all three contexts:
- **Code Context**: Refactoring monolith to microservices
- **Process Context**: Updating release process for service-based deployment
- **Agent Context**: Enhancing knowledge for microservice architecture patterns

### Coordination Approach

**Phase 1: Architecture Definition**
- Define microservice architecture across contexts
- Establish service boundaries and interfaces
- Create cross-context migration strategy
- Define success criteria for each context

**Phase 2: Foundation Implementation**
- Create core infrastructure in code context
- Develop service deployment process
- Enhance agent knowledge for microservices
- Validate cross-context understanding

**Phase 3: Incremental Migration**
- Migrate services one domain at a time
- Update process artifacts for each domain
- Enhance agent guidance for each domain
- Validate after each domain migration

**Phase 4: Finalization**
- Complete final service migrations
- Finalize process documentation
- Complete agent knowledge enhancement
- Validate full microservice architecture

### Cross-Context Interfaces

**Service Deployment Interface:**
```yaml
service:
  name: "user-service"
  version: "1.0.0"
  dependencies:
    - name: "auth-service"
      version: "^2.0.0"
    - name: "notification-service"
      version: "^1.5.0"
  deployment:
    strategy: "blue-green"
    validation:
      - type: "health-check"
        endpoint: "/health"
      - type: "smoke-test"
        scenarios: ["login", "profile-update"]
```

**Process-to-Agent Guidance:**
```
Microservice Validation Guidance:
1. Verify service isolation
2. Validate interface contracts
3. Confirm resilience patterns
4. Check observability implementation
5. Verify deployment independence
```

**Agent-to-Code Analysis:**
```
Architecture Analysis:
- Service boundary integrity: Strong
- Interface design quality: Good
- Dependency management: Needs improvement
- Resilience implementation: Adequate
- Recommendations: Enhance circuit breaker implementation
```
```

<important>
Cross-context coordination requires careful attention to boundaries, interfaces, and consistent principle application. Focus on clear communication, explicit integration points, and coordinated implementation to ensure successful changes across multiple system contexts.
</important>