"""
Step definitions for the Command Line Interface feature.
"""
from behave import given, when, then
from unittest.mock import MagicMock, patch
import os
import tempfile
from pathlib import Path

# Import common steps
from tests.bdd.steps.common.setup_steps import *
from tests.bdd.steps.common.cli_steps import *
from tests.bdd.steps.common.assertion_steps import *


# Most of the necessary steps are already defined in the common step files
# This file adds any CLI-specific steps that aren't already covered


@given('I have the Portal Explorer CLI installed')
def step_given_have_portal_explorer_cli_installed(context):
    """Set up the Portal Explorer CLI installation."""
    # This is already defined in common/cli_steps.py
    # Here we just provide a redirect to maintain organization
    from tests.bdd.steps.common.cli_steps import step_given_have_portal_explorer_cli_installed
    step_given_have_portal_explorer_cli_installed(context)


@given('I have configured my API key and space ID')
def step_given_have_configured_api_key_and_space_id(context):
    """Set up API key and space ID configuration."""
    # This is already defined in common/cli_steps.py
    # Here we just provide a redirect to maintain organization
    from tests.bdd.steps.common.cli_steps import step_given_have_configured_api_key_and_space_id
    step_given_have_configured_api_key_and_space_id(context)


@given('I am using the Portal Explorer CLI')
def step_given_am_using_portal_explorer_cli(context):
    """Set up the Portal Explorer CLI context."""
    # This is already defined in common/cli_steps.py
    # Here we just provide a redirect to maintain organization
    from tests.bdd.steps.common.cli_steps import step_given_am_using_portal_explorer_cli
    step_given_am_using_portal_explorer_cli(context)


@when('I check if the Portal Explorer CLI is installed')
def step_when_check_cli_installed(context):
    """Check if the Portal Explorer CLI is installed."""
    # Mock checking for CLI installation
    context.cli_check_result = {
        "installed": True,
        "version": "1.0.0",
        "path": "/usr/local/bin/gather-manager"
    }


@then('I should be able to access it from the command line')
def step_then_can_access_from_command_line(context):
    """Check that the CLI is accessible from the command line."""
    assert context.cli_check_result["installed"], "CLI should be installed"
    assert context.cli_check_result["path"], "CLI should have a valid path"


@then('it should be installed in the standard location')
def step_then_installed_in_standard_location(context):
    """Check that the CLI is installed in the standard location."""
    assert "/bin/" in context.cli_check_result["path"], "CLI should be installed in a standard location"


@given('I have set up custom output formats')
def step_given_have_custom_output_formats(context):
    """Set up custom output formats."""
    # Mock setting up custom output formats
    context.custom_formats = {
        "json": True,
        "csv": True,
        "table": True
    }


@when('I run a command with a custom output format')
def step_when_run_command_with_custom_format(context):
    """Run a command with a custom output format."""
    # Use the common step to run a command with a format option
    step_when_run_command(context, "gather-manager list-maps --format json")


@then('the output should be formatted according to my preference')
def step_then_output_formatted_to_preference(context):
    """Check that the output is formatted according to the preference."""
    assert context.result is not None, "Result should be defined"
    # For JSON format, check for JSON-like indicators
    assert "{" in context.result["output"] or "[" in context.result["output"], "Output should have JSON format indicators"


@given('I have created aliases for common commands')
def step_given_have_command_aliases(context):
    """Set up aliases for common commands."""
    # Mock setting up command aliases
    context.command_aliases = {
        "gm-list": "gather-manager list-maps",
        "gm-explore": "gather-manager explore",
        "gm-validate": "gather-manager validate-portals"
    }


@when('I use an alias to run a command')
def step_when_use_alias_for_command(context):
    """Use an alias to run a command."""
    # Choose an alias
    alias = "gm-list"
    context.used_alias = alias
    
    # Get the full command
    full_command = context.command_aliases[alias]
    
    # Run the command using the common step
    step_when_run_command(context, full_command)


@then('it should execute the corresponding full command')
def step_then_execute_full_command(context):
    """Check that the alias executes the corresponding full command."""
    assert context.result is not None, "Result should be defined"
    assert context.result["exit_code"] == 0, "Command should execute successfully"
    
    # We know it executed the list-maps command if it shows maps
    assert "Map ID" in context.result["output"] or "map1" in context.result["output"], "Should execute the list-maps command"


@given('I have configured custom colors for the CLI output')
def step_given_have_custom_colors(context):
    """Set up custom colors for CLI output."""
    # Mock setting up custom colors
    context.custom_colors = {
        "header": "blue",
        "success": "green",
        "warning": "yellow",
        "error": "red"
    }


@when('I run a command that produces colored output')
def step_when_run_command_with_color(context):
    """Run a command that produces colored output."""
    # Run a command that would have colored output
    step_when_run_command(context, "gather-manager list-maps --color")


@then('the output should use my custom color scheme')
def step_then_use_custom_color_scheme(context):
    """Check that the output uses the custom color scheme."""
    # This is difficult to test in a mock - in a real test we'd check for ANSI color codes
    # For now, just verify the command ran successfully
    assert context.result is not None, "Result should be defined"
    assert context.result["exit_code"] == 0, "Command should execute successfully"


@given('I have a previous version of the CLI')
def step_given_have_previous_cli_version(context):
    """Set up a previous version of the CLI."""
    # Mock having an older version
    context.installed_version = "0.9.0"
    context.latest_version = "1.0.0"


@when('I run the update command')
def step_when_run_update_command(context):
    """Run the update command."""
    # Mock running an update command
    context.update_result = {
        "success": True,
        "old_version": context.installed_version,
        "new_version": context.latest_version
    }


@then('it should update to the latest version')
def step_then_update_to_latest_version(context):
    """Check that the CLI updates to the latest version."""
    assert context.update_result["success"], "Update should be successful"
    assert context.update_result["new_version"] == context.latest_version, "Should update to the latest version"


@given('I need to see available commands')
def step_given_need_see_available_commands(context):
    """Set up the need to see available commands."""
    # This is a placeholder setup
    context.need_command_help = True


@when('I run the help command')
def step_when_run_help_command(context):
    """Run the help command."""
    # Use the common step to run help
    step_when_run_command_without_arguments(context, "gather-manager")


@then('I should see documentation for all commands')
def step_then_see_documentation_for_all_commands(context):
    """Check that the output includes documentation for all commands."""
    # This is already tested in the common assertion steps
    # Reuse the existing step
    step_then_all_commands_listed(context)
